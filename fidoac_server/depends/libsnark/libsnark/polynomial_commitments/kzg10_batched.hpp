/** @file
 *****************************************************************************
 * @author     This file is part of libff, developed by Clearmatics Ltd
 *             (originally developed by SCIPR Lab) and contributors
 *             (see AUTHORS).
 * @copyright  MIT license (see LICENSE file)
 *****************************************************************************/

#ifndef __LIBSNARK_POLYNOMIAL_COMMITMENTS_KZG10_BATCHED_HPP__
#define __LIBSNARK_POLYNOMIAL_COMMITMENTS_KZG10_BATCHED_HPP__

#include "libsnark/polynomial_commitments/kzg10.hpp"

/// Reference:
/// - [GWC19]:
///   Title: "PLONK: Permutations over Lagrange-bases for Oecumenical
///           Noninteractive arguments of Knowledge"
///   eprint: https://eprint.iacr.org/2019/953.pdf

namespace libsnark
{

/// Batched version of KZG10, as described in Section 3 of [GWC19]. Supports
/// evaluation of arbitrary number of polynomials at 2 points, requiring a
/// fixed-size witness (of 2 elements of G1), which can be verified with 2
/// pairings (similarly to KZG10) and a number of group operations proportional
/// to the number of polynomials.
///
/// Note, this could be extended to the case of N evaluation points (and
/// thereby N sets of polynomials).
template<typename ppT> class kzg10_batched_2_point
{
public:
    using Field = libff::Fr<ppT>;

    /// The srs generated by the setup step. This is denoted PK in [KZG10]
    /// section 3.2.
    using srs = typename kzg10<ppT>::srs;

    using commitment = typename kzg10<ppT>::commitment;

    /// Claimed evaluations of 2 groups of polynomials, fs and gs, at 2 points
    /// z_1 and z_2.  f_s are evaluated at z_1 and g_s are evaluated at z_2.
    class evaluations
    {
    public:
        std::vector<Field> s_1s;
        std::vector<Field> s_2s;

        evaluations(std::vector<Field> &&fs, std::vector<Field> &&gs);
    };

    /// The evaluation witness created by the prover in the interactive
    /// protocol. Given a challenge (gamma_1 and gamma_2) and the claimed
    /// evaluation of 2 sets of polynomials, the prover returns this witness,
    /// proving the correctness of the evaluations. A verifier holding the
    /// commitments for all polynomials in the 2 sets can then verify this
    /// witness.
    class evaluation_witness
    {
    public:
        // Part of witness corresponding to evaluations of f_1s.
        const libff::G1<ppT> W_1;
        // Part of witness corresponding to evaluations of f_2s.
        const libff::G1<ppT> W_2;

        evaluation_witness(
            const libff::G1<ppT> &W_1, const libff::G1<ppT> &W_2);
    };

    /// Evaluate the polynomials and return an evaluation object. f_s are
    /// evaluated at z_1 and g_s are evaluated at z_2.
    static evaluations evaluate_polynomials(
        const std::vector<polynomial<Field>> &fs,
        const std::vector<polynomial<Field>> &gs,
        const Field &z_1,
        const Field &z_2);

    /// Generate a witness to prove the correctness of these evaluations.
    /// Returns a `multi_point_evaluation_witness` object holding this data.
    static evaluation_witness create_evaluation_witness(
        const std::vector<polynomial<Field>> &fs,
        const std::vector<polynomial<Field>> &gs,
        const Field &z_1,
        const Field &z_2,
        const evaluations &evaluations,
        const srs &srs,
        const Field &gamma_1,
        const Field &gamma_2);

    /// Given an `evaluation` and `evaluation_witness` generated for
    /// polynomials with commitments `cm_1s` and `cm_2s`, verify the witnesses
    /// using randomness r. This convinces the verifier that the given
    /// polynomials attain the claimed values at the evaluation points z_1 and
    /// z_2.
    static bool verify_evaluations(
        const Field &z_1,
        const Field &z_2,
        const evaluations &evaluations,
        const srs &srs,
        const Field &gamma_1,
        const Field &gamma_2,
        const evaluation_witness &witness,
        const std::vector<commitment> &cm_1s,
        const std::vector<commitment> &cm_2s,
        const Field &r);
};

} // namespace libsnark

#include "libsnark/polynomial_commitments/kzg10_batched.tcc"

#endif // __LIBSNARK_POLYNOMIAL_COMMITMENTS_KZG10_BATCHED_HPP__
