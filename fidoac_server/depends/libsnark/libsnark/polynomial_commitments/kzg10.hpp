/** @file
 *****************************************************************************
 * @author     This file is part of libff, developed by Clearmatics Ltd
 *             (originally developed by SCIPR Lab) and contributors
 *             (see AUTHORS).
 * @copyright  MIT license (see LICENSE file)
 *****************************************************************************/

#ifndef __LIBSNARK_POLYNOMIAL_COMMITMENTS_KZG10_HPP__
#define __LIBSNARK_POLYNOMIAL_COMMITMENTS_KZG10_HPP__

#include "libsnark/common/data_structures/polynomial.hpp"

#include <libff/algebra/curves/public_params.hpp>
#include <libff/algebra/fields/fp.hpp>
#include <vector>

/// Reference:
/// - [KZG10]:
///   Title: "Constant-Size Commitments to Polynomials and Their Applications"
///   eprint: https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf

namespace libsnark
{

/// Implementation of the scheme described in [KZG10]. The interface and types
/// diverge slightly from [KZG10] in some places (in order to use the generic
/// interface defined above). These differences are noted explicitly in the
/// relevant places.
template<typename ppT> class kzg10
{
public:
    using Field = libff::Fr<ppT>;

    /// The srs generated by the setup step. This is denoted PK in [KZG10]
    /// section 3.2.
    class srs
    {
    public:
        srs(std::vector<libff::G1<ppT>> &&alpha_powers_g1,
            const libff::G2<ppT> &alpha_g2);

        /// Array of powers of secret \alpha, encoded in G1:
        /// [1]_1, [\alpha]_1, [\alpha^2]_1, ..., [\alpha^{t}]_1
        std::vector<libff::G1<ppT>> alpha_powers_g1;

        /// Secret \alpha encoded in G2:  [\alpha]_2
        libff::G2<ppT> alpha_g2;
    };

    using commitment = libff::G1<ppT>;

    /// A witness for the evaluation of a polynomial at some point.
    using evaluation_witness = libff::G1<ppT>;

    /// Intended only for testing.
    static srs setup_from_secret(size_t max_degree, const Field &alpha);

    /// Create a PK. A more secure way to do this is through a simple
    /// multi-party computation. max_degree is the maximum degree polynomial
    /// which can be used with the generated srs (denoted t in [KZG10] section
    /// 3.2).
    static srs setup(size_t max_degree);

    /// The Commit function from [KZG10] section 3.2. Commit to a polynomial
    /// \phi, using some srs.
    static commitment commit(const srs &srs, const polynomial<Field> &phi);

    /// VerifyPoly from the original scheme. Verify that a commitment C
    /// (generated with some srs) is a valid commitment for some polynomial phi.
    static bool verify_poly(
        const srs &srs, commitment C, const polynomial<Field> &phi);

    static Field evaluate_polynomial(const polynomial<Field> &phi, Field i);

    /// createwitness from [KZG10] section 3.2. Create a witness for the
    /// evaluation of the polynomial phi at i.
    static evaluation_witness create_evaluation_witness(
        const polynomial<Field> &phi,
        const Field &i,
        const Field &evaluation,
        const srs &srs);

    /// VerifyEval from [KZG10] section 3.2. Given an srs, a commitment to a
    /// polynomial, a claimed evaluation of the polynomial, and a witness for
    /// that evaluation, check that the evaluation is indeed valid for the
    /// committed polynomial.
    static bool verify_evaluation(
        const Field &i,
        const Field &evaluation,
        const srs &srs,
        const evaluation_witness &witness,
        const commitment &C);
};

} // namespace libsnark

#include "libsnark/polynomial_commitments/kzg10.tcc"

#endif // __LIBSNARK_POLYNOMIAL_COMMITMENTS_KZG10_HPP__
